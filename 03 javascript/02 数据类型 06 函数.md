### 1.概述
#### 1.1 函数的声明(三种)
+ 1）function命令声明方式：
    - function命令声明的代码区块,就是一个函数。
    - function命令后面的是函数名。
    - 函数名后面的圆括号是传入函数的参数
    - 函数体放在大括号里面
    ```
    function print(s){
        console.log(s);
    }
    ```
+ 2）函数表达式采用变量赋值的方式
    - 将匿名函数赋值给变量。这个匿名函数又称函数表达式，因为赋值语句的等号右侧只能放表达式
    ```
    var print = function(s){
        console.log(s)
    }
    ```
    - 采用函数表达式声明函数时，function命令后面不带有函数名。若加上了函数名，该函数只在函数体内部有效，在函数体外无效。
    ```
    var print = function x(){
        console.log(typeof x)
    }
    
    x  // ReferenceError: x is not defined
    
    这种写法的用处有两个
    1）可以在函数体内部调用自身
    2）方便除错
    ```
    - 函数表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾可以不用加分号。总之，两种声明函数的方式，差别细微，近乎等价。

+ 3）function构造函数
    - 可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当作函数体。如果只有一个参数，该参数就是函数体。
    - Function构造函数可以不使用new命令，返回结果是一样的。

**1.2 函数的重复声明**    
如果同一个函数被多次声明，后面声明则覆盖了前面的声明。由于函数名的提升，前面声明的在任何时候都是无效的。

**1.3 圆括号运算符，return语句和递归**
+ 调用函数时，使用圆括号运算符。圆括号中，可以加入函数的参数。
+ 函数体内的return语句表示返回。当遇到return语句，就直接返回return后面的那个表达式的值。即使后面还有语句，也不会得到执行。return语句所带的表达式，就是函数的返回值。
+ 函数可以调用自身，就是递归。
```
function fib(num) {
  if (num === 0) return 0;
  if (num === 1) return 1;
  return fib(num - 2) + fib(num - 1);
}

fib(6) // 8
```

**1.4 第一等公民**      
JavaScript语言将函数看做一种值，与其他值（数值、字符串、布尔值）地位相同，所以被称为第一等公民。凡是可以使用值得地方，就能使用函数。

**1.5 函数名的提升**    
JavaScript引擎将函数名视为变量名，所以采用function命令声明函数时，整个函数会像变量一样，提升到代码头部。

#### 2.函数的属性和方法
**2.1 name属性**
+ 返回函数的名字
+ 如果是变量赋值定义的函数，那么name属性返回变量名。
+ 如果变量是一个具名函数，则返回function关键字之后的那个函数名。

**2.2 length属性**
+ 返回函数预期传入的参数个数，即函数定义之中的参数个数。
+ length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”

**2.3 toString()**
+ 返回一个字符串，内容是函数的源码
+ 对于原生函数，toString()方法返回`function(){native code}`

#### 3.函数作用域
**3.1 定义**
+ 指的是变量存在的范围
+ ES5规定JavaScript只有两种作用域
    - 全局作用域：变量在整个程序中一直存在。对于顶层函数来说，函数外部声明的变量就是全局变量。
    - 函数作用域：变量只在函数体内部存在
+ ES6新增了块级作用域

**3.2 函数内部的变量提升**
函数作用域内部也会产生“变量提升”现象。

**3.3 函数本身的作用域**
+ 函数本身是一个值，且有自己的作用域。
+ 它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。
+ 函数体内部声明的函数，作用域绑定函数体内部。
```
function foo(){
    var x=1;
    function bar(){
        console.log(x);
    }
    return bar;
}

var x = 2;
var f = foo();
f() //1

函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了“闭包”现象。
```

#### 4.参数
**4.1 概述**
+ 运行时，会需要提供外部数据。不同的外部数据会得到不同的结果。这种外部数据称之为参数。

**4.2 参数的省略**
+ 函数参数不是必需的，JavaScript允许省略参数。
+ 运行时无论提供多少个参数或者不提供参数，JavaScript都不会报错。省略的参数的值变为undefined。
+ 函数length属性与实际传入的参数个数无关，它只会反应函数预期传入的参数个数。
+ 没办法只省略靠前参数，保留靠后的参数，如果一定要这么做，可以显示传入undefined。
```
function f(a,b){
    return a;
}

f( , 1) // SyntaxError: Unexpected token ,(…)
f(undefined, 1) // undefined
```

**4.3 传递方式**
+ 传值传递：函数参数是原始类型的值（数值、字符串、布尔值）。意味着，在函数体内修改参数值，不会影响到函数外部。
+ 传址传递：函数参数是复合类型的值（数组、对象、其他函数）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。
```
var obj = { p:1 };
function f(o){
    o.p = 2;
}
f(obj);
obj.p //2
传入函数f的是参数对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。

var obj = [1, 2, 3];
function f(o) {
  o = [2, 3, 4];
}
f(obj);
obj // [1, 2, 3]
在函数f内部，参数对象obj被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（o）的值实际是参数obj的地址，重新对o赋值导致o指向另一个地址，保存在原地址上的值当然不受影响。
```

**4.4 同名参数**
+ 若出现同名参数，则取最后出现的那个值。如果要获得第一个a的值，可以使用arguments对象。
```
function f(a,a){
    console.log(arguments[0]);
}
f(1)  //1
```

**4.5 arguments 对象**
+ 1.定义
    - 由于JavaScript允许函数有不定数目的参数，为了函数体内部读取所有参数，便诞生了arguments对象。
    - 正常模式下，arguments对象可以在运行时修改。
    - 严格模式下，arguments对象不会影响到实际的函数参数。arguments对象的length属性，可以判断函数调用时共带了几个参数。
+ 2.与数组的关系
    - 虽然arguments很像数组，但它只是一个对象。数组专有的方法（比如slice和forEach），不能再arguments对象上直接使用。
    - 想让arguments对象使用数组方法，真正解决方法是将arguments转为真正的数组。slice方法和逐一填入新数组方法
    ```
    var args = Array.prototype.slice.call(arguments);

    // 或者
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    ```
+ 3.callee属性
    - 用于返回它对应的原函数，达到调用自身的目的。严格模式下禁用它，所以不建议使用。

#### 5.函数的其他知识点
**5.1 闭包**
+ 理解闭包，首先了解变量作用域（全局作用域和函数作用域，函数内部可以直接读取全局变量，但函数外部无法读取函数内部声明的变量）
+ 链式作用域：父对象的所有变量对子对象是可见的，反之则不成立。
+ 闭包的理解
    - 理解：定义在一个函数内部的函数。
    - 特点：它可以“记住”诞生的环境。
    - 本质：是函数内部和函数外部连接的桥梁。
+ 闭包的用处
    - 读取函数内部的变量
    - 让这些变量始终保持在内存中，使他的诞生环境一直存在。
    - 可以封装对象的私有属性和私有方法
+ 闭包可以看作是函数内部作用域的一个接口
+ 注意：外层函数每次运行，都会生成一个新的闭包。而这个闭包又会保留外层函数的内部变量，内存消耗较大。因此不能滥用闭包，否则会造成网页性能问题。

**5.2 立即调用的函数表达式（IIFE）**
+ JavaScript中，圆括号()是一种运算符，跟在函数名之后，表示调用该函数。eg：print()表示调用print函数。
+ JavaScript引擎规定，如果function关键字出现在行首，一律解释为语句。所以行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以报错。
```
function(){ /* code */ }();
// SyntaxError: Unexpected token (

解决方法：不要让function出现在行首，让引擎理解成一个表达式，最简单的处理，将其放在圆括号内。
(function(){ /* code */ }());
// 或者
(function(){ /* code */ })();
这种就称之为“立即调用的函数表达式”
```
+ 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。目的有两个
    - 不必为函数命名，避免了污染全局变量。
    - IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。（推荐，可避免污染全局变量）

#### 6.eval命令（因为存在安全风险，所以不推荐使用）
**6.1 基本用法**
+ 接受一个字符串作为参数，并将这个字符串当作语句执行。如果不能当作语句运行，就会报错。
+ 放在eval中的字符串，应该有独自存在的意义，不能用来以eval以外的命令配合使用。
```
eval('return;'); // Uncaught SyntaxError: Illegal return statement
return不能单独使用，必须在函数中使用。
```
+ eval参数若不是字符串，则会原样返回。
+ eval没有自己的作用域，当eval命令修改了外部变量a的值，则存在安全风险。为了防止这种风险，JavaScript规定，使用严格模式，eval内部声明的变量，不会影响到外部作用域。

**6.2 eval的别名调用**
+ eval的别名调用形式五花八门，如果不是直接调用，都属于别名调用。引擎只能分辨eval()形式是直接调用。
+ 为了保证eval的别名不影响代码优化，JavaScript的标准规定，凡是使用别名执行eval，eval内部一律使用全局作用域。

## 完结 2019/8/23