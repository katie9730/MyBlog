JavaScript是浏览器的内置脚本语言。也就是说，浏览器内置了JavaScript引擎，并且提供各种借口，让JavaScript脚本可以控制浏览器的各种功能。一旦网页内嵌了JavaScript脚本，浏览器加载网页，就会去执行脚本，从而达到操作浏览器的目的，实现网页的各种动态效果。
******
#### 1.代码嵌入网页的方法   
主要有三种方法：
+ <script>元素直接嵌入代码
+ <script>标签加载外部脚本
+ 事件属性
+ URL协议    

**1.1 <script>元素直接嵌入代码**
- <script>标签有一个type属性，用来指定脚本类型。它可以设为两种值。    
    + text/javascript：默认值，可省略。适用于老式浏览器。
    + application/javascript：适用于较新的浏览器。
注意：若type属性的值，浏览器不认识，那么就不会执行其中的代码。

**1.2<script>标签加载外部脚本**
+ 如果脚本文件使用了非英语字符，还应该注明字符的编码
`<script charset="utf-8" src="https://www.example.com/script.js"></script>`
+ 为了防止攻击者篡改外部脚本，script标签允许设置一个integrity属性，写入该外部脚本的Hash签名，用来验证脚本的一致性。一旦发现有人更改，浏览器就会拒绝加载。
`<script src="/assets/application.js"
  integrity="sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs=">
</script>`

**1.3事件属性**    
是指事件属性可以写入JavaScript代码。当指定事件发生时，就会调用这些代码。
`<button id="myBtn" onclick="console.log(this.id)">点击</button>`

**1.4URL 协议**
+ URL 支持javascript:协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。
+ javascript协议的常见用途是书签脚本Bookmarklet。为了防止书签替换掉当前文档，可以在脚本前加上void，或者在脚本最后加上void 0
`<a href="javascript: new Date().toLocaleTimeString();void 0;">点击</a>`

#### 2.script元素
**2.1 工作原理**
+ 网页加载流程
    - 浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。
    - 解析过程中，浏览器发现<script>元素，就暂停解析（原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。），把网页渲染的控制权转交给 JavaScript 引擎。
    - 如果<script>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。
    - JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。
+ 什么是'阻塞效应':外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态的时候。
    - 解决方案：将<script>标签放在页面底部，而不是头部。这样即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容，而不是面对一张空白的页面。如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码写入页面，而不是连接外部脚本文件，这样能缩短加载时间。脚本文件都放在网页尾部加载，还有一个好处。因为在 DOM 结构生成之前就调用 DOM 节点，JavaScript 会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时 DOM 肯定已经生成了。
    - 解决方案一：设定DOMContentLoaded事件的回调函数。DOMContentLoaded事件只有在 DOM 结构生成之后才会触发。
    - 解决方案二：使用<script>标签的onload属性。当<script>标签指定的外部脚本文件下载和解析完成，会触发一个load事件，可以把所需执行的代码，放在这个事件的回调函数里面。
+ js，css的执行顺序都是根据页面中出现的顺序决定的。这是为了脚本之间的依赖关系不收到破坏。当然，加载时依然会产生'阻塞效应',必须等到全部加载完成，才会继续页面渲染。
+ 对于同一个域名的资源下载，TCP对于资源下载是有限制的（最多下载6-20）。不过来自不同域名的资源，就没有了这个限制。

**2.2 defer属性**       
为了解决脚本文件下载阻塞网页渲染的问题，一个方法是对<script>元素加入defer属性。它的作用是延迟脚本的执行，等到DOM加载生成后，再执行脚本。
`<script src="a.js" defer></script>`

defer属性的运行流程如下
1. 浏览器开始解析 HTML 网页。
2. 解析过程中，发现带有defer属性的<script>元素。
3. 浏览器继续往下解析 HTML 网页，同时并行下载<script>元素加载的外部脚本。
4. 浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。

有了defer属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。  
对于内置而不是加载外部脚本的script标签，以及动态生成的script标签，defer属性不起作用。
另外，使用defer加载的外部脚本不应该使用document.write方法。

**2.3 async属性**     
async也可以解决'阻塞效应'
`<script src="a.js" async></script>`

async属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。
1. 浏览器开始解析 HTML 网页。
2. 解析过程中，发现带有async属性的script标签。
3. 浏览器继续往下解析 HTML 网页，同时并行下载<script>标签中的外部脚本。
4. 脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。
5. 脚本执行完毕，浏览器恢复解析 HTML 网页。

async属性可以保证脚本下载的同时，浏览器继续渲染。不过这个属性不能确保脚本的执行顺序。哪个脚本先下载结束，就先执行哪个脚本。另外使用async属性的脚本文件，不应该使用document.write方法。

defer属性和async属性到底应该使用哪一个？   
一般来说，如果脚本之间没有依赖关系，就使用async属性，如果脚本之间有依赖关系，就使用defer属性。如果同时使用async和defer属性，后者不起作用，浏览器行为由async属性决定。

**2.4 脚本的动态加载**
<script>元素可以动态生成，生成后再插入页面，从而实现脚本的动态加载。
+ 好处：不会阻塞页面渲染，不会造成浏览器假死。
+ 坏处：无法保证脚本的执行顺序。不过可以设置async属性为fasle进行避免。

**2.5 加载使用的协议**
默认采用http协议下载
`<script src="example.js"></script>`
采用https协议下载
`<script src="https://example.js"></script>`
根据页面本身的协议决定加载协议
`<script src="//example.js"></script>`

#### 3.浏览器的组成
浏览器的核心是两部分：渲染引擎和JavaScript解释器（又称javaScript引擎）

**3.1 渲染引擎**
主要作用：将网页代码渲染为用户视觉可以感知的平面文档。   

不同浏览器有不同的渲染引擎：
+ Firefox：Gecko 引擎
+ Safari：WebKit 引擎
+ Chrome：Blink 引擎
+ IE: Trident 引擎
+ Edge: EdgeHTML 引擎

渲染引擎分4步处理网页（并非严格按照这个顺序执行）
1. 解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。
2. 对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。
3. 布局：计算出渲染树的布局（layout）。
4. 绘制：将渲染树绘制到屏幕。

**3.2 重流和重绘**
+ 布局流：渲染树转换为网页布局（具有阻塞效应）
+ 绘制：布局显示到页面的过程（具有阻塞效应）
+ 重流和重绘：页面生成后，脚本操作和样式表操作，还有用户的互动。（重流和重绘并不一定一起发生，重流必然导致重绘，重绘不一定需要重流）

注意：尽量设法降低重绘的次数和成本，因为代价高。

优化技巧
+ 读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。
+ 缓存 DOM 信息。
+ 不要一项一项地改变样式，而是使用 CSS class 一次性改变样式。
+ 使用documentFragment操作 DOM
+ 动画使用absolute定位或fixed定位，这样可以减少对其他元素的影响。
+ 只在必要时才显示隐藏元素。
+ 使用window.requestAnimationFrame()，因为它可以把代码推迟到下一次重流时执行，而不是立即要求页面重流。
+ 使用虚拟 DOM（virtual DOM）库。

**3.3 JavaScript 引擎**    
读取网页中的JavaScript代码，对其处理后运行。

javascript是一种解释型语言，不需要编译，由解释器实时运行。   
好处:运行修改方便，刷新页面就可以重新解释。
缺点：每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。

现代浏览器采用“即时编译”，即字节码只在运行时编译，用到哪行就编译哪行，并且把编译结果缓存。

## 完结 2019/7/3