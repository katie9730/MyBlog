#### 一：概述    
**1.1 生成方法**   
  对象是JavaScript语言的核心概念。是一组“键值对”的集合，且是一种无序的复合数据集合。
  ```
  var obj = {
      foo:'Hello',
      bar:'world'
  }
  //大括号定义一个对象，赋值给变量obj。所以obj就指向一个对象。
  //该对象包含两个键值对，也可称为两个“成员”。
  //第一个键值对`foo:'Hello'`。其中foo是“键名”，Hello是“键值”
  ```
**1.2 键名**    
所有的键名都是字符串，这里的引号可加可不加。      
+ 如果键名是数值，则会自动转为字符串；   
+ 如果键名不符合标准，则必须加上引号，不然会报错。     
+ 对象的每一个键名也可以称为“属性”。键值可以是任何数据类型(比如函数)。如果是函数的话，我们通常就会称这个属性为“方法”，然后向函数那样去调用;如果属性的值是一个对象，就形成了链式引用。
    ```
    // 对象的属性指向函数。
    var obj = {
        p: function(x){
            return 2 * x;
        }
    }
    obj.p(1)  //2    
    
    //对象的属性指向对象
    var o1 = {}
    var o2 = {bar:'hello'}
    o1.foo = o2;
    o1.foo.bar  //'hello'     o1的属性foo指向对象o2，就可以链式引用o2的属性了。
    ```
    + 对象的属性之间是用逗号分隔，则最后一个属性后面可以加逗号，也可以不加。
    + 属性可以动态创建，不必在对象声明时就指定。
    ```
    var obj = {};
    obj.foo = 123;
    obj.foo  //123
    ```
**1.3 对象的引用**
  - 如果不同的变量名指向同一个对象，则他都是这个对象的引用(指向同一个内存地址)，修改其中一个变量，就会影响到其他的变量。称之为浅拷贝。
  - 若取消某一个变量对于原对象的引用，则不会影响到另一个变量。则称之为深拷贝。
  - 不过这种引用局限于对象。如果两个变量指向同一个原始类型的值，则变量这时都是值得拷贝。
  ```
    //会影响
    var o1 = {};
    var o2 = o1;
    o1.a = 1;
    o2.a // 1
    o2.b = 2;
    o1.b // 2
    
    //不会影响
    var o1 = {};
    var o2 = o1;
    
    o1 = 1;
    o2 // {}
  
  ```
**1.4 表达式还是语句？**
 - javaScript引擎规定：当遇到行首是一个大括号时，无论它是对象还是代码块，一律解释为代码块。
 - 如果要解释为对象，则最好在大括号前加上圆括号。因为圆括号内只能是表达式，所以确保大括号只能解释为对象。
 - eval语句反应的差异最为明显
  ```
  eval('{foo:123}')   //123
  eval('({foo:123})')   //{foo:123}
  ```
  
 #### 2.属性的操作     
**2.1 属性的读取**     
+ 读取对象属性的两种方法，一种是使用点运算符，另一种是使用方括号运算符。
```
var obj = {
    p:'Hello World'
}
obj.p   //'Hello World'
obj['p']   //'Hello World'

//注意：
//引用对象obj的foo属性时，如果使用点运算符，foo就是字符串
//如果使用方括号运算符，且不使用引号，那么foo就是一个变量
```
+ 方括号运算符内部还可以使用表达式；不过数字键可以不加引号，因为它会自动转成字符串，且不能使用点运算符(会报错)，只可使用方括号运算符。
```
obj['hello' + 'world']
obj[3 + 3]

var obj = {
  0.7: 'Hello World'
};

obj['0.7'] // "Hello World"
obj[0.7] // "Hello World"
```
**2.2 属性的赋值**
+ 点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。
    ```
    var obj = {};
    obj.foo = 'Hello';
    obj['bar'] = 'world';
    ```
+ JavaScript 允许属性的'后绑定'。可以在任意时刻新增属性，没必要在定义对象的时候就直接定义好属性。

**2.3 属性的查看**     
查看一个对象本身的所有属性，可以使用Object.keys方法。
```
var obj = {
    key1:1,
    key2:2
}
Object.keys(obj)   //['key1','key2']
```

**2.4 属性的删除：delete命令**
```
var obj = { p:1 };
Object.keys(obj)  //['p']

delete obj.p  //true   删除后返回为true
obj.p  //undefined
Object.keys(obj)
```
> 注意：删除一个不存在的属性，delete不报错，且返回为true。
因此不能根据delete命令的结果，认定某个属性是否存在。假若delete命令返回false，那么该属性则为存在，且不可删除。delete命令只能删除对象本身的属性，无法删除继承的属性。

**2.5 属性是否存在：in运算符**
+ 用于对象是否包含某个属性，即键名。包含返回true，否则返回false。
+ in运算符无法区分自身属性还是继承属性，这时就可以使用对象的hasOwnProperty方法来判断了。
```
var obj = { p:1 }
'p' in obj //true; in的左边是字符串，右边是对象
'toString' in obj  //true
```
```
var obj = {};
if('toString' in obj){
    console.log(obj.hasOwnProperty('toString'))   //false
}
```

**2.6 属性的遍历：for...in循环**
+ 遍历的对象是所有可遍历的属性，会跳过不可遍历的属性
+ 遍历对象自身的属性，也可遍历继承的属性（除了默认为不可遍历的），这时可以结合使用hasOwnProperty方法，在循环内部判断一下该属性是否为对象自身的属性。
```
var obj = {a:1, b:2, c:3};
for (var i in obj){
    console.log('键名',i);
    console.log('键值',obj[i])
}
```
```
var person = { name:'老张' };
for (var key in person){
    if(person.hasOwnProperty(key)){
        console.log(key);
    }
}
```
#### 3. with语句
如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。
```
\\格式
with(对象){
    语句;
}
```
```
var obj = {};
with (obj){
    p1 = 4;
    p2 = 5;
}

obj.p1 //undefined
p1 //4
// 对象obj并没有p1属性，对p1赋值等于创造了一个全局变量p1。正确的写法应该是，先定义对象obj的属性p1，然后在with区块内操作它。
```

## 完结 2019/8/22